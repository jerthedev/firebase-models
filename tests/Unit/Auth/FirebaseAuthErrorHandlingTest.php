<?php

namespace JTD\FirebaseModels\Tests\Unit\Auth;

use JTD\FirebaseModels\Auth\FirebaseGuard;
use JTD\FirebaseModels\Auth\FirebaseUserProvider;
use JTD\FirebaseModels\Auth\User;
use JTD\FirebaseModels\Tests\Helpers\FirebaseAuthMock;
use Illuminate\Http\Request;
use Illuminate\Contracts\Hashing\Hasher;
use Mockery as m;
use JTD\FirebaseModels\Tests\TestSuites\UnitTestSuite;
use PHPUnit\Framework\Attributes\Test;

/**
 * FirebaseAuthErrorHandlingTest
 * 
 * Converted from describe/it structure to PHPUnit class methods.
 * Generated by PHPUnit 12 Modernization Tool.
 */
class FirebaseAuthErrorHandlingTest extends UnitTestSuite
{
    protected function setUp(): void
    {
        parent::setUp();
        $this->clearFirestoreMocks();
        // Mock Firebase Auth for error scenarios
        $this->firebaseAuth = m::mock(\Kreait\Firebase\Contract\Auth::class);
        // Mock Hasher
        $this->hasher = m::mock(Hasher::class);
        // Create provider instance
        $this->provider = new FirebaseUserProvider(
        $this->firebaseAuth,
        User::class,
        $this->hasher
        );
        // Mock Request
        $this->request = m::mock(Request::class);
        // Create guard instance
        $this->guard = new FirebaseGuard(
        $this->provider,
        $this->request,
        $this->firebaseAuth
        );
    }

    protected function tearDown(): void
    {
        m::close();
        parent::tearDown();
    }

    #[Test]
    public function it_handles_expired_tokens_gracefully()
    {
        $this->request->shouldReceive('query')->with('token')->andReturn('expired-token');
        $this->request->shouldReceive('input')->with('token')->andReturn(null);
        $this->request->shouldReceive('header')->with('Authorization')->andReturn(null);
        $this->request->shouldReceive('cookie')->with('firebase_token')->andReturn(null);
        $this->firebaseAuth->shouldReceive('verifyIdToken')
        ->with('expired-token')
        ->andThrow(new \Exception('Token expired'));
        $user = $this->guard->user();
        expect($user)->toBeNull();
        expect($this->guard->check())->toBeFalse();
    }

    #[Test]
    public function it_handles_malformed_tokens_gracefully()
    {
        $this->request->shouldReceive('query')->with('token')->andReturn('malformed.token.here');
        $this->request->shouldReceive('input')->with('token')->andReturn(null);
        $this->request->shouldReceive('header')->with('Authorization')->andReturn(null);
        $this->request->shouldReceive('cookie')->with('firebase_token')->andReturn(null);
        $this->firebaseAuth->shouldReceive('verifyIdToken')
        ->with('malformed.token.here')
        ->andThrow(new \Exception('Malformed token'));
        $user = $this->guard->user();
        expect($user)->toBeNull();
    }

    #[Test]
    public function it_handles_revoked_tokens_gracefully()
    {
        $this->firebaseAuth->shouldReceive('verifyIdToken')
        ->with('revoked-token')
        ->andThrow(new \Exception('Token revoked'));
        $result = $this->guard->validate(['token' => 'revoked-token']);
        expect($result)->toBeFalse();
    }

    #[Test]
    public function it_handles_network_errors_during_token_verification()
    {
        $this->firebaseAuth->shouldReceive('verifyIdToken')
        ->with('network-error-token')
        ->andThrow(new \Exception('Network error'));
        $result = $this->guard->attempt(['token' => 'network-error-token']);
        expect($result)->toBeFalse();
    }

    #[Test]
    public function it_handles_user_not_found_in_firebase_auth()
    {
        $this->firebaseAuth->shouldReceive('getUser')
        ->with('non-existent-uid')
        ->andThrow(new \Exception('User not found'));
        $user = $this->provider->retrieveById('non-existent-uid');
        expect($user)->toBeNull();
    }

    #[Test]
    public function it_handles_firebase_auth_service_unavailable()
    {
        $this->firebaseAuth->shouldReceive('getUser')
        ->with('service-down-uid')
        ->andThrow(new \Exception('Service unavailable'));
        $user = $this->provider->retrieveById('service-down-uid');
        expect($user)->toBeNull();
    }

    #[Test]
    public function it_handles_invalid_uid_format()
    {
        $this->firebaseAuth->shouldReceive('getUser')
        ->with('invalid-uid-format')
        ->andThrow(new \Kreait\Firebase\Exception\Auth\UserNotFound());
        $user = $this->provider->retrieveById('invalid-uid-format');
        expect($user)->toBeNull();
    }

    #[Test]
    public function it_handles_missing_required_claims()
    {
        // Mock token with missing 'sub' claim
        $mockToken = m::mock(\Lcobucci\JWT\UnencryptedToken::class);
        $mockClaims = m::mock();
        $mockClaims->shouldReceive('get')->with('sub')->andReturn(null);
        $mockToken->shouldReceive('claims')->andReturn($mockClaims);
        $this->firebaseAuth->shouldReceive('verifyIdToken')
        ->with('missing-sub-token')
        ->andReturn($mockToken);
        $this->provider->shouldReceive('retrieveById')
        ->with(null)
        ->andReturn(null);
        $result = $this->guard->attempt(['token' => 'missing-sub-token']);
        expect($result)->toBeFalse();
    }

    #[Test]
    public function it_handles_corrupted_token_claims()
    {
        $mockToken = m::mock(\Lcobucci\JWT\UnencryptedToken::class);
        $mockClaims = m::mock();
        $mockClaims->shouldReceive('get')->with('sub')->andThrow(new \Exception('Corrupted claims'));
        $mockToken->shouldReceive('claims')->andReturn($mockClaims);
        $this->firebaseAuth->shouldReceive('verifyIdToken')
        ->with('corrupted-claims-token')
        ->andReturn($mockToken);
        $result = $this->guard->attempt(['token' => 'corrupted-claims-token']);
        expect($result)->toBeFalse();
    }

    #[Test]
    public function it_handles_empty_credentials_gracefully()
    {
        $user = $this->provider->retrieveByCredentials([]);
        expect($user)->toBeNull();
    }

    #[Test]
    public function it_handles_null_credentials_gracefully()
    {
        $user = $this->provider->retrieveByCredentials(['token' => null]);
        expect($user)->toBeNull();
    }

    #[Test]
    public function it_handles_credentials_validation_with_invalid_user()
    {
        $mockUser = m::mock(User::class);
        $mockUser->shouldReceive('getAuthIdentifier')->andReturn('test-uid');
        $this->firebaseAuth->shouldReceive('verifyIdToken')
        ->with('different-user-token')
        ->andThrow(new \Exception('Invalid token'));
        $result = $this->provider->validateCredentials($mockUser, ['token' => 'different-user-token']);
        expect($result)->toBeFalse();
    }

    #[Test]
    public function it_handles_invalid_model_class_gracefully()
    {
        $provider = new FirebaseUserProvider(
        $this->firebaseAuth,
        'NonExistentClass',
        $this->hasher
        );
        expect(function () {
        $provider->createModel();
        })->toThrow(\Error::class);
    }

    #[Test]
    public function it_handles_model_without_firebaseauthenticatable_interface()
    {
        // Create a provider with a regular class instead of FirebaseAuthenticatable
        $provider = new FirebaseUserProvider(
        $this->firebaseAuth,
        \stdClass::class,
        $this->hasher
        );
        expect(function () {
        $provider->createModel();
        })->toThrow(\Error::class);
    }

    #[Test]
    public function it_handles_malformed_authorization_header()
    {
        $this->request->shouldReceive('query')->with('token')->andReturn(null);
        $this->request->shouldReceive('input')->with('token')->andReturn(null);
        $this->request->shouldReceive('header')->with('Authorization')->andReturn('Malformed header');
        $this->request->shouldReceive('cookie')->with('firebase_token')->andReturn(null);
        $token = $this->guard->getTokenForRequest();
        expect($token)->toBeNull();
    }

    #[Test]
    public function it_handles_empty_authorization_header()
    {
        $this->request->shouldReceive('query')->with('token')->andReturn(null);
        $this->request->shouldReceive('input')->with('token')->andReturn(null);
        $this->request->shouldReceive('header')->with('Authorization')->andReturn('');
        $this->request->shouldReceive('cookie')->with('firebase_token')->andReturn(null);
        $token = $this->guard->getTokenForRequest();
        expect($token)->toBeNull();
    }

    #[Test]
    public function it_handles_bearer_header_without_token()
    {
        $this->request->shouldReceive('query')->with('token')->andReturn(null);
        $this->request->shouldReceive('input')->with('token')->andReturn(null);
        $this->request->shouldReceive('header')->with('Authorization')->andReturn('Bearer ');
        $this->request->shouldReceive('cookie')->with('firebase_token')->andReturn(null);
        $token = $this->guard->getTokenForRequest();
        expect($token)->toBe('');
    }

    #[Test]
    public function it_handles_multiple_simultaneous_authentication_attempts()
    {
        // Simulate multiple rapid authentication attempts
        $tokens = ['token1', 'token2', 'token3'];
        $results = [];
        foreach ($tokens as $token) {
        $this->firebaseAuth->shouldReceive('verifyIdToken')
        ->with($token)
        ->andThrow(new \Exception('Rate limited'));
        $results[] = $this->guard->validate(['token' => $token]);
        }
        // All should fail gracefully
        foreach ($results as $result) {
        expect($result)->toBeFalse();
        }
    }

    #[Test]
    public function it_handles_large_token_payloads_gracefully()
    {
        // Simulate a very large token that might cause memory issues
        $largeToken = str_repeat('a', 10000);
        $this->firebaseAuth->shouldReceive('verifyIdToken')
        ->with($largeToken)
        ->andThrow(new \Exception('Token too large'));
        $result = $this->guard->validate(['token' => $largeToken]);
        expect($result)->toBeFalse();
    }

    #[Test]
    public function it_handles_missing_firebase_configuration_gracefully()
    {
        // This would typically be handled at the service provider level,
        // but we can test that the guard handles null Firebase Auth
        expect(function () {
        new FirebaseGuard(
        $this->provider,
        $this->request,
        null // This would cause a type error in real usage
        );
        })->toThrow(\TypeError::class);
    }

    #[Test]
    public function it_handles_user_logout_when_no_user_authenticated()
    {
        // Should not throw an error
        $this->guard->logout();
        expect($this->guard->check())->toBeFalse();
        expect($this->guard->user())->toBeNull();
    }

    #[Test]
    public function it_handles_multiple_logout_calls()
    {
        // Should not throw an error
        $this->guard->logout();
        $this->guard->logout();
        $this->guard->logout();
        expect($this->guard->check())->toBeFalse();
    }

    #[Test]
    public function it_handles_setting_null_user()
    {
        $this->guard->setUser(null);
        expect($this->guard->check())->toBeFalse();
        expect($this->guard->user())->toBeNull();
    }

}
