<?php

namespace JTD\FirebaseModels\Tests\Unit\Cache;

use JTD\FirebaseModels\Cache\RequestCache;
use JTD\FirebaseModels\Tests\TestSuites\UnitTestSuite;
use PHPUnit\Framework\Attributes\Test;

/**
 * RequestCacheTest
 *
 * Converted from describe/it structure to PHPUnit class methods.
 * Generated by PHPUnit 12 Modernization Tool.
 */
class RequestCacheTest extends UnitTestSuite
{
    protected function setUp(): void
    {
        parent::setUp();
        // Clear cache and reset stats before each test
        RequestCache::clear();
        RequestCache::resetStats();
        RequestCache::enable();
    }

    protected function tearDown(): void
    {
        // Clean up after each test
        RequestCache::clear();
        RequestCache::resetStats();
        parent::tearDown();
    }

    #[Test]
    public function it_store_and_retrieve_values()
    {
        RequestCache::put('test_key', 'test_value');
        expect(RequestCache::get('test_key'))->toBe('test_value');
        expect(RequestCache::has('test_key'))->toBeTrue();
    }

    #[Test]
    public function it_returns_null_for_nonexistent_keys()
    {
        expect(RequestCache::get('non_existent'))->toBeNull();
        expect(RequestCache::has('non_existent'))->toBeFalse();
    }

    #[Test]
    public function it_store_complex_data_types()
    {
        $data = [
            'array' => [1, 2, 3],
            'object' => (object) ['prop' => 'value'],
            'null' => null,
            'boolean' => true,
            'number' => 42.5,
        ];
        RequestCache::put('complex_data', $data);
        $retrieved = RequestCache::get('complex_data');
        expect($retrieved)->toBe($data);
    }

    #[Test]
    public function it_forget_cached_values()
    {
        RequestCache::put('forget_me', 'value');
        expect(RequestCache::has('forget_me'))->toBeTrue();
        RequestCache::forget('forget_me');
        expect(RequestCache::has('forget_me'))->toBeFalse();
        expect(RequestCache::get('forget_me'))->toBeNull();
    }

    #[Test]
    public function it_clear_all_cached_values()
    {
        RequestCache::put('key1', 'value1');
        RequestCache::put('key2', 'value2');
        RequestCache::put('key3', 'value3');
        expect(RequestCache::size())->toBe(3);
        RequestCache::clear();
        expect(RequestCache::size())->toBe(0);
        expect(RequestCache::get('key1'))->toBeNull();
        expect(RequestCache::get('key2'))->toBeNull();
        expect(RequestCache::get('key3'))->toBeNull();
    }

    #[Test]
    public function it_tracks_cache_hits_and_misses()
    {
        // Initial stats should be zero
        $stats = RequestCache::getStats();
        expect($stats['hits'])->toBe(0);
        expect($stats['misses'])->toBe(0);
        // Miss on non-existent key
        RequestCache::get('non_existent');
        $stats = RequestCache::getStats();
        expect($stats['misses'])->toBe(1);
        expect($stats['hits'])->toBe(0);
        // Store and hit
        RequestCache::put('test_key', 'test_value');
        RequestCache::get('test_key');
        $stats = RequestCache::getStats();
        expect($stats['hits'])->toBe(1);
        expect($stats['misses'])->toBe(1);
        // Another hit
        RequestCache::get('test_key');
        $stats = RequestCache::getStats();
        expect($stats['hits'])->toBe(2);
        expect($stats['misses'])->toBe(1);
    }

    #[Test]
    public function it_tracks_and_deletes()
    {
        RequestCache::put('key1', 'value1');
        RequestCache::put('key2', 'value2');
        $stats = RequestCache::getStats();
        expect($stats['sets'])->toBe(2);
        expect($stats['deletes'])->toBe(0);
        RequestCache::forget('key1');
        $stats = RequestCache::getStats();
        expect($stats['deletes'])->toBe(1);
    }

    #[Test]
    public function it_calculates_hit_rate_correctly()
    {
        // No operations yet
        expect(RequestCache::getHitRate())->toBe(0.0);
        // 1 miss, 0 hits = 0% hit rate
        RequestCache::get('non_existent');
        expect(RequestCache::getHitRate())->toBe(0.0);
        // 1 miss, 1 hit = 50% hit rate
        RequestCache::put('test_key', 'value');
        RequestCache::get('test_key');
        expect(RequestCache::getHitRate())->toBe(50.0);
        // 1 miss, 2 hits = 66.67% hit rate
        RequestCache::get('test_key');
        expect(RequestCache::getHitRate())->toBe(66.67);
    }

    #[Test]
    public function it_reset_statistics()
    {
        RequestCache::put('key', 'value');
        RequestCache::get('key');
        RequestCache::get('non_existent');
        $stats = RequestCache::getStats();
        expect($stats['hits'])->toBeGreaterThan(0);
        expect($stats['misses'])->toBeGreaterThan(0);
        expect($stats['sets'])->toBeGreaterThan(0);
        RequestCache::resetStats();
        $stats = RequestCache::getStats();
        expect($stats['hits'])->toBe(0);
        expect($stats['misses'])->toBe(0);
        expect($stats['sets'])->toBe(0);
        expect($stats['deletes'])->toBe(0);
        expect($stats['clears'])->toBe(0);
    }

    #[Test]
    public function it_respects_maximum_cache_size()
    {
        // Set a small max size for testing
        RequestCache::setMaxItems(5);
        // Fill cache beyond max size
        for ($i = 0; $i < 10; $i++) {
            RequestCache::put("key_{$i}", "value_{$i}");
        }
        // Cache should not exceed max size
        expect(RequestCache::size())->toBeLessThanOrEqual(5);
        expect(RequestCache::getMaxItems())->toBe(5);
    }

    #[Test]
    public function it_get_cache_size_and_keys()
    {
        RequestCache::put('key1', 'value1');
        RequestCache::put('key2', 'value2');
        RequestCache::put('key3', 'value3');
        expect(RequestCache::size())->toBe(3);
        $keys = RequestCache::keys();
        expect($keys)->toContain('key1');
        expect($keys)->toContain('key2');
        expect($keys)->toContain('key3');
        expect(count($keys))->toBe(3);
    }

    #[Test]
    public function it_flush_cache_when_getting_large()
    {
        // Set max items and fill cache
        RequestCache::setMaxItems(10);
        for ($i = 0; $i < 8; $i++) {
            RequestCache::put("key_{$i}", "value_{$i}");
        }
        $sizeBefore = RequestCache::size();
        RequestCache::flush();
        $sizeAfter = RequestCache::size();
        // Flush should reduce size when cache is getting large
        expect($sizeAfter)->toBeLessThanOrEqual($sizeBefore);
    }

    #[Test]
    public function it_be_disabled_and_enabled()
    {
        expect(RequestCache::isEnabled())->toBeTrue();
        RequestCache::disable();
        expect(RequestCache::isEnabled())->toBeFalse();
        // Operations should be no-ops when disabled
        RequestCache::put('test_key', 'test_value');
        expect(RequestCache::get('test_key'))->toBeNull();
        expect(RequestCache::has('test_key'))->toBeFalse();
        RequestCache::enable();
        expect(RequestCache::isEnabled())->toBeTrue();
        // Operations should work again when enabled
        RequestCache::put('test_key', 'test_value');
        expect(RequestCache::get('test_key'))->toBe('test_value');
    }

    #[Test]
    public function it_remember_values_using_callback()
    {
        $callCount = 0;
        $callback = function () use (&$callCount) {
            $callCount++;

            return 'computed_value';
        };
        // First call should execute callback
        $result1 = RequestCache::remember('remember_key', $callback);
        expect($result1)->toBe('computed_value');
        expect($callCount)->toBe(1);
        // Second call should return cached value without executing callback
        $result2 = RequestCache::remember('remember_key', $callback);
        expect($result2)->toBe('computed_value');
        expect($callCount)->toBe(1); // Callback not called again
    }

    #[Test]
    public function it_generate_consistent_cache_keys()
    {
        $key1 = RequestCache::generateKey('get', 'users', ['where' => ['active' => true]]);
        $key2 = RequestCache::generateKey('get', 'users', ['where' => ['active' => true]]);
        expect($key1)->toBe($key2);
    }

    #[Test]
    public function it_generates_different_keys_for_different_parameters()
    {
        $key1 = RequestCache::generateKey('get', 'users', ['where' => ['active' => true]]);
        $key2 = RequestCache::generateKey('get', 'users', ['where' => ['active' => false]]);
        expect($key1)->not->toBe($key2);
    }

    #[Test]
    public function it_generates_different_keys_for_different_operations()
    {
        $key1 = RequestCache::generateKey('get', 'users', []);
        $key2 = RequestCache::generateKey('count', 'users', []);
        expect($key1)->not->toBe($key2);
    }

    #[Test]
    public function it_generates_different_keys_for_different_collections()
    {
        $key1 = RequestCache::generateKey('get', 'users', []);
        $key2 = RequestCache::generateKey('get', 'posts', []);
        expect($key1)->not->toBe($key2);
    }

    #[Test]
    public function it_dump_cache_contents_for_debugging()
    {
        RequestCache::put('debug_key', 'debug_value');
        $dump = RequestCache::dump();
        expect($dump)->toHaveKey('cache');
        expect($dump)->toHaveKey('stats');
        expect($dump)->toHaveKey('enabled');
        expect($dump)->toHaveKey('max_items');
        expect($dump['cache']['debug_key'])->toBe('debug_value');
        expect($dump['enabled'])->toBeTrue();
    }
}
