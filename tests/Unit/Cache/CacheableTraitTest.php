<?php

namespace JTD\FirebaseModels\Tests\Unit\Cache;

use JTD\FirebaseModels\Cache\Concerns\Cacheable;
use JTD\FirebaseModels\Cache\RequestCache;
use JTD\FirebaseModels\Cache\PersistentCache;
use JTD\FirebaseModels\Cache\CacheManager;
use JTD\FirebaseModels\Cache\QueryCacheKey;
use JTD\FirebaseModels\Tests\TestSuites\UnitTestSuite;
use Illuminate\Support\Collection;
use PHPUnit\Framework\Attributes\Test;

// Test model class
class TestCacheableQuery
{
    use Cacheable;

    protected string $collection = 'test_collection';
    protected array $wheres = [];
    protected ?int $limitValue = null;
    protected array $selects = ['*'];

    public function __construct(string $collection = 'test_collection')
    {
        $this->collection = $collection;
    }

    // Mock query execution methods
    protected function parentGet(array $columns = ['*']): Collection
    {
        return new Collection([
            (object) ['id' => '1', 'name' => 'Test 1'],
            (object) ['id' => '2', 'name' => 'Test 2'],
        ]);
    }

    protected function parentFirst(array $columns = ['*']): ?object
    {
        return (object) ['id' => '1', 'name' => 'First Item'];
    }

    protected function parentCount(string $columns = '*'): int
    {
        return 42;
    }

    protected function parentExists(): bool
    {
        return true;
    }

    // Public methods that use caching
    public function get(array $columns = ['*']): Collection
    {
        return $this->getCached('get', [$columns]);
    }

    public function first(array $columns = ['*']): ?object
    {
        return $this->getCached('first', [$columns]);
    }

    public function count(string $columns = '*'): int
    {
        return $this->getCached('count', [$columns]);
    }

    public function exists(): bool
    {
        return $this->getCached('exists');
    }

    // Helper methods for testing
    public function where(string $field, string $operator, mixed $value): static
    {
        $this->wheres[] = compact('field', 'operator', 'value');
        return $this;
    }

    public function limit(int $limit): static
    {
        $this->limitValue = $limit;
        return $this;
    }

    public function getCollection(): string
    {
        return $this->collection;
    }

    // Make protected methods public for testing
    public function shouldCache(): bool
    {
        return $this->cacheEnabled && RequestCache::isEnabled();
    }
}

/**
 * CacheableTraitTest
 * 
 * Converted from describe/it structure to PHPUnit class methods.
 * Generated by PHPUnit 12 Modernization Tool.
 */
class CacheableTraitTest extends UnitTestSuite
{
    protected function setUp(): void
    {
        parent::setUp();
        // Use array cache driver for testing
        config([
        'cache.default' => 'array',
        'cache.stores.array' => [
        'driver' => 'array',
        'serialize' => false,
        ],
        'firebase-models.cache.store' => 'array',
        ]);
        // Set default store to array for testing
        PersistentCache::setDefaultStore('array');
        RequestCache::clear();
        RequestCache::resetStats();
        RequestCache::enable();
        try {
        PersistentCache::flush('array');
        } catch (\Exception $e) {
        // Ignore cache flush errors in tests
        }
        PersistentCache::resetStats();
        PersistentCache::enable();
        // Configure cache manager to use array store
        CacheManager::configure([
        'request_cache_enabled' => true,
        'persistent_cache_enabled' => true,
        'default_ttl' => 3600,
        'default_store' => 'array',
        'auto_promote' => true,
        ]);
        $this->query = new TestCacheableQuery();
    }

    protected function tearDown(): void
    {
        RequestCache::clear();
        RequestCache::resetStats();
        try {
        PersistentCache::flush('array');
        } catch (\Exception $e) {
        // Ignore cache flush errors in tests
        }
        PersistentCache::resetStats();
        parent::tearDown();
    }

    #[Test]
    public function it_caches_query_results()
    {
        // First call should execute query and cache result
        $result1 = $this->query->get();
        $stats1 = RequestCache::getStats();
        expect($result1)->toBeInstanceOf(Collection::class);
        expect($result1->count())->toBe(2);
        expect($stats1['sets'])->toBe(1);
        expect($stats1['hits'])->toBe(0);
        expect($stats1['misses'])->toBe(1);
        // Second call should return cached result
        $result2 = $this->query->get();
        $stats2 = RequestCache::getStats();
        expect($result2)->toBe($result1);
        expect($stats2['hits'])->toBe(1);
        expect($stats2['misses'])->toBe(1);
    }

    #[Test]
    public function it_caches_different_methods_separately()
    {
        $getResult = $this->query->get();
        $firstResult = $this->query->first();
        $countResult = $this->query->count();
        $existsResult = $this->query->exists();
        $stats = RequestCache::getStats();
        expect($getResult)->toBeInstanceOf(Collection::class);
        expect($firstResult)->toBeObject();
        expect($countResult)->toBe(42);
        expect($existsResult)->toBeTrue();
        // Should have 4 cache sets (one for each method)
        expect($stats['sets'])->toBe(4);
    }

    #[Test]
    public function it_generates_different_cache_keys_for_different_parameters()
    {
        $result1 = $this->query->get(['id', 'name']);
        $result2 = $this->query->get(['id']);
        $stats = RequestCache::getStats();
        // Should have 2 cache sets (different column parameters)
        expect($stats['sets'])->toBe(2);
        expect($stats['hits'])->toBe(0);
    }

    #[Test]
    public function it_disable_caching_for_specific_queries()
    {
        $result1 = $this->query->withoutCache()->get();
        $result2 = $this->query->withoutCache()->get();
        $stats = RequestCache::getStats();
        // No caching should occur
        expect($stats['sets'])->toBe(0);
        expect($stats['hits'])->toBe(0);
        expect($stats['misses'])->toBe(0);
    }

    #[Test]
    public function it_reenable_caching_after_disabling()
    {
        $this->query->withoutCache();
        expect($this->query->shouldCache())->toBeFalse();
        $this->query->withCache();
        expect($this->query->shouldCache())->toBeTrue();
        $result = $this->query->get();
        $stats = RequestCache::getStats();
        expect($stats['sets'])->toBe(1);
    }

    #[Test]
    public function it_set_custom_cache_keys()
    {
        $result = $this->query->cacheKey('custom_key')->get();
        expect(RequestCache::has('custom_key'))->toBeTrue();
        expect(RequestCache::get('custom_key'))->toBe($result);
    }

    #[Test]
    public function it_add_cache_tags()
    {
        $this->query->cacheTags(['users', 'active']);
        $tags = $this->query->getCacheTags();
        expect($tags)->toBe(['users', 'active']);
        // Add more tags
        $this->query->cacheTags(['recent']);
        $tags = $this->query->getCacheTags();
        expect($tags)->toBe(['users', 'active', 'recent']);
    }

    #[Test]
    public function it_clear_cache_for_specific_queries()
    {
        // Cache some results
        $this->query->get();
        $this->query->first();
        expect($this->query->isCached('get'))->toBeTrue();
        expect($this->query->isCached('first'))->toBeTrue();
        // Clear cache
        $this->query->clearCache();
        expect($this->query->isCached('get'))->toBeFalse();
        expect($this->query->isCached('first'))->toBeFalse();
    }

    #[Test]
    public function it_invalidate_specific_operations()
    {
        // Cache multiple operations
        $this->query->get();
        $this->query->first();
        $this->query->count();
        expect($this->query->isCached('get'))->toBeTrue();
        expect($this->query->isCached('first'))->toBeTrue();
        expect($this->query->isCached('count'))->toBeTrue();
        // Invalidate only get and first
        $this->query->invalidateCache(['get', 'first']);
        expect($this->query->isCached('get'))->toBeFalse();
        expect($this->query->isCached('first'))->toBeFalse();
        expect($this->query->isCached('count'))->toBeTrue();
    }

    #[Test]
    public function it_flush_all_cache_for_collection()
    {
        $query1 = new TestCacheableQuery('collection1');
        $query2 = new TestCacheableQuery('collection2');
        // Cache results for both collections
        $query1->get();
        $query2->get();
        expect($query1->isCached('get'))->toBeTrue();
        expect($query2->isCached('get'))->toBeTrue();
        // Flush only collection1
        $query1->flushCache();
        expect($query1->isCached('get'))->toBeFalse();
        expect($query2->isCached('get'))->toBeTrue();
    }

    #[Test]
    public function it_check_if_query_cached()
    {
        expect($this->query->isCached('get'))->toBeFalse();
        $result = $this->query->get();
        expect($this->query->isCached('get'))->toBeTrue();
        expect($this->query->isCached('first'))->toBeFalse();
    }

    #[Test]
    public function it_warm_cache_by_executing_query()
    {
        expect($this->query->isCached('get'))->toBeFalse();
        $result = $this->query->warmCache('get');
        expect($this->query->isCached('get'))->toBeTrue();
        expect($result)->toBeInstanceOf(Collection::class);
    }

    #[Test]
    public function it_provides_cache_statistics()
    {
        $this->query->get();
        $this->query->get(); // Cache hit
        $stats = $this->query->getCacheStats();
        expect($stats['hits'])->toBe(1);
        expect($stats['misses'])->toBe(2); // RequestCache miss + PersistentCache miss on first call
        expect($stats['sets'])->toBe(2);   // RequestCache set + PersistentCache set on first call
        expect($stats['hit_rate'])->toBe(33.33); // 1 hit / 3 total operations = 33.33%
    }

    #[Test]
    public function it_provides_debug_information()
    {
        $this->query->cacheTags(['test'])->cacheKey('debug_key');
        $debugInfo = $this->query->getCacheDebugInfo();
        expect($debugInfo)->toHaveKey('cache_enabled');
        expect($debugInfo)->toHaveKey('should_cache');
        expect($debugInfo)->toHaveKey('custom_cache_key');
        expect($debugInfo)->toHaveKey('cache_tags');
        expect($debugInfo)->toHaveKey('collection');
        expect($debugInfo)->toHaveKey('cache_key_get');
        expect($debugInfo)->toHaveKey('is_cached_get');
        expect($debugInfo)->toHaveKey('cache_stats');
        expect($debugInfo['cache_enabled'])->toBeTrue();
        expect($debugInfo['custom_cache_key'])->toBe('debug_key');
        expect($debugInfo['cache_tags'])->toBe(['test']);
        expect($debugInfo['collection'])->toBe('test_collection');
    }

    #[Test]
    public function it_supports_remember_method_for_future_compatibility()
    {
        $result = $this->query->remember(3600, 'get');
        expect($result)->toBeInstanceOf(Collection::class);
        expect($this->query->isCached('get'))->toBeTrue();
    }

    #[Test]
    public function it_supports_rememberforever_method_for_future_compatibility()
    {
        $result = $this->query->rememberForever('get');
        expect($result)->toBeInstanceOf(Collection::class);
        expect($this->query->isCached('get'))->toBeTrue();
    }

    #[Test]
    public function it_generates_different_cache_keys_for_different_query_conditions()
    {
        $query1 = $this->query->where('status', '=', 'active');
        $query2 = (new TestCacheableQuery())->where('status', '=', 'inactive');
        $result1 = $query1->get();
        $result2 = $query2->get();
        $stats = RequestCache::getStats();
        // Should have 2 cache sets (different where conditions)
        expect($stats['sets'])->toBe(2);
        expect($stats['hits'])->toBe(0);
    }

    #[Test]
    public function it_respects_global_cache_enabledisable_state()
    {
        RequestCache::disable();
        expect($this->query->shouldCache())->toBeFalse();
        $result = $this->query->get();
        $stats = RequestCache::getStats();
        expect($stats['sets'])->toBe(0);
        RequestCache::enable();
        expect($this->query->shouldCache())->toBeTrue();
    }

}
